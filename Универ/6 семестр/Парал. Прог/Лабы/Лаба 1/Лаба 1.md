<div class="title">
	<div class="header">
		<p>МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ</p>
		<p>ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ</p>
		<p class="header__university-name">«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА» (БГТУ им. В.Г. Шухова)</p>
		<p>Кафедра программного обеспечения вычислительной техники и автоматизированных систем<p>
	</div>
	<div class="main">
		<p class="main__title">Лабораторная работа №1</p>
		<p class="main__subject">по дисциплине: «Параллельное программирование»</p>
		<p class="main__topic">тема: «Сравнение парадигм конкурентности и параллелизма при разработке многопоточных программ в ОС Linux»</p>
	</div>
	<div class="footer">
		<div class="footer__student-info">
			<p class="footer__student-info__title">Выполнил студент группы ПВ-222</p>
			<p class="footer__student-info__item">Короткунов Александр Александрович</p>
		</div>
		<div class="footer__teachers-info">
			<p class="footer__teachers-info__title">Проверили</p>
			<p class="footer_teachers-info__item">Гвоздевский Игорь Николаевич</p>
			<p class="footer_teachers-info__item">Четвертухин Виктор Романович</p>
			<p class="footer_teachers-info__item">Островский Алексей Мичеславович</p>
		</div>
	</div>
	<div class="date">
		<p>Белгород 2025 г.</p>
	</div>
</div>

**Цель работы:** исследовать чувствительность вычислительной схемы из индивидуального задания к:
1. ситуациям конкурентности, когда несколько потоков разделяют одно процессорное ядро.
2. ситуациям параллелизма, когда каждый поток выполняется на отдельном ядре процессора (нет конкуренции за вычислительные ресурсы).

**Задание 1.** Выполнить индивидуальное задание, связанное с использованием POSIX Threads для реализации вычислительной задачи с контролируемым распределением потоков по процессорным ядрам. Следует декомпозировать вычислительную задачу, вычленив сущности для потоковой обработки.

$$S=\sum^N_{i=1}\frac{cos(i^3)+i^4e^{-i}+\ln(i+1)}{\sqrt{i^2+tan(i)+1}+i!}$$

```c
#define _GNU_SOURCE
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sched.h>

#define NUM_THREADS 2 // Количество потоков
#define N 50000000

// Функция для вычисления подвыражений суммы
void *compute_partial_sum(void *arg)
{
    long thread_id = (long)arg;
    double *local_sum = malloc(sizeof(double)); // Выделяем память для результата
    *local_sum = 0.0;

    // Разделение индексов между потоками
    for (long i = thread_id + 1; i <= N; i += NUM_THREADS)
    {
        double numerator = cos(pow(i, 3)) + pow(i, 4) * exp(-i) + log(i + 1);
        double denominator = sqrt(i * i + tan(i) + 1) + tgamma(i + 1);

        // Проверяем на допустимость знаменатель
        if (isnan(denominator) || denominator == 0.0 || isnan(numerator))
        {
            printf("Недопустимое значение при i = %ld\n", i);
            continue; // Пропускаем текущую итерацию
        }

        *local_sum += numerator / denominator;
    }

    return local_sum; // Возвращаем локальную сумму
}

// Функция для привязки потока к определенному ядру
void pin_thread_to_core(int core_id)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);
    pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
}

int main(int argc, char *argv[])
{
    pthread_t threads[NUM_THREADS];
    double total_sum = 0.0;

    // Проверяем количество аргументов
    if (argc != 2)
    {
        fprintf(stderr, "Использование: %s <режим>\n", argv[0]);
        fprintf(stderr, "Режимы: 1 - Потоки на разных ядрах, 2 - Все потоки на одном ядре\n");
        return EXIT_FAILURE;
    }

    // Парсим режим из аргумента
    int mode = atoi(argv[1]);
    if (mode != 1 && mode != 2)
    {
        fprintf(stderr, "Некорректный режим. Используйте 1 или 2.\n");
        return EXIT_FAILURE;
    }

    if (mode == 1)
    {
        printf("Режим: Потоки на разных ядрах\n");
    }
    else
    {
        printf("Режим: Все потоки на одном ядре\n");
    }

    // Создаем потоки
    for (long t = 0; t < NUM_THREADS; t++)
    {
        if (pthread_create(&threads[t], NULL, compute_partial_sum, (void *)t))
        {
            fprintf(stderr, "Ошибка создания потока\n");
            return EXIT_FAILURE;
        }

        // Привязка потока к ядру
        if (mode == 1)
        {
            pin_thread_to_core(t % NUM_THREADS); // Каждый поток к своему ядру
        }
        else if (mode == 2)
        {
            pin_thread_to_core(0); // Все потоки на ядре 0
        }
    }

    // Собираем результаты от потоков
    for (int t = 0; t < NUM_THREADS; t++)
    {
        double *local_sum;
        pthread_join(threads[t], (void **)&local_sum); 
        total_sum += *local_sum;
        free(local_sum); // Освобождаем память, выделенную потоком
    }

    // Вывод результата
    printf("Результат суммы S: %.10f\n", total_sum);

    return EXIT_SUCCESS;
}
```

**Задание 2.** Построить графики зависимости вычислительной эффективности программы от числа потоков для ситуаций (а) и (б), проанализировать накладные расходы, связанные с переключением контекста, оценить влияние гиперпоточности.

|Число потоков|Параллельность|Конкурентость|
|---|---|---|
| 1   | 10.695 | 10.138 |
|2|10.153|5.826|
|3|7.146|8.549|
|4|5.729|9.307|

![[Pasted image 20250216141258.png]]

![[Pasted image 20250216141327.png]]

> \* на графиках по вертикальной оси располагается время выполнения программы

<div class="page-break"></div>

### Анализ накладных расходов на переключение контекста

**Для 1 потока**:
- Параллельность: 10.695
- Конкурентость: 10.138

В случае с одним потоком время выполнения почти не отличается в обоих режимах. Это ожидаемо, так как для одного потока нет необходимости в переключении контекста.

**Для 2 потоков**:
- Параллельность: 10.153
- Конкурентость: 5.826

	Здесь видно значительное улучшение производительности при использовании конкуренции, где два потока эффективно используют одно ядро. Это связано с тем, что с 2 потоками на одном ядре процессор, вероятно, успевает эффективно переключать контексты, используя время простоя одного потока для работы другого.

**Для 3 потоков**:
- Параллельность: 7.146
- Конкурентость: 8.549

	Увеличение количества потоков приводит к небольшому снижению производительности при параллельном распределении потоков на ядра, но конкуренция на одном ядре оказывает негативное влияние. В этом случае переключения контекста начинают терять эффективность, так как процессор должен распределять время между большим количеством потоков.

**Для 4 потоков**:
- Параллельность: 5.729
- Конкурентость: 9.307

	При 4 потоках мы видим дальнейшее снижение производительности при конкуренции. Это может быть связано с тем, что на одном ядре становится сложнее эффективно управлять несколькими потоками из-за того, что процессор вынужден тратить все больше времени на переключение контекста, что увеличивает накладные расходы.

<div class="page-break"></div>

### Оценка влияния гиперпоточности

- **С 2 потоками**: Программа выигрывает от гиперпоточности, так как процессор может использовать оба потока на одном ядре, эффективно деля его время. Мы видим улучшение во времени выполнения при конкуренции (5.826 против 10.153), что говорит о том, что гиперпоточность дает прирост.

- **С 3 и 4 потоками**: С увеличением числа потоков влияние гиперпоточности становится менее очевидным, и даже начинает иметь негативное влияние. Например, при 3 потоках время выполнения в конкуренции (8.549) оказывается хуже, чем при параллельности (7.146), а при 4 потоках время при конкуренции (9.307) значительно хуже, чем при параллельности (5.729).

### Выводы
1. **Переключение контекста**:
	- Накладные расходы на переключение контекста начинают существенно влиять на производительность с увеличением числа потоков. Особенно это заметно, когда потоки начинают конкурировать за ресурсы на одном ядре, что приводит к дополнительным потерям времени на переключение контекстов и управление многими потоками.
	- Для 2 потоков гиперпоточность работает эффективно, но с ростом числа потоков накладные расходы на переключение контекста начинают доминировать, что снижает производительность.
2. **Влияние гиперпоточности**:
	- Гиперпоточность эффективно работает для 2 потоков, улучшая производительность.
	- При 3 и 4 потоках гиперпоточность начинает приносить вред из-за того, что процессор сталкивается с конкуренцией за ресурсы на одном ядре, что ведет к большему времени на переключение контекста.

Таким образом, гиперпоточность приносит выгоду при небольшом количестве потоков, но при большем количестве потоков лучше использовать параллельное распределение потоков на отдельные ядра, чтобы избежать излишних накладных расходов, связанных с переключением контекста.
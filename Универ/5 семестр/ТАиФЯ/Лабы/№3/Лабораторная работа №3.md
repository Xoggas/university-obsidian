<div class="title">
	<div class="header">
		<p>МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ</p>
		<p>ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ</p>
		<p class="header__university-name">«БЕЛГОРОДСКИЙ ГОСУДАРСТВЕННЫЙ ТЕХНОЛОГИЧЕСКИЙ УНИВЕРСИТЕТ им. В. Г. ШУХОВА» (БГТУ им. В.Г. Шухова)</p>
		<p>Кафедра программного обеспечения вычислительной техники и автоматизированных систем<p>
	</div>
	<div class="main">
		<p class="main__title">Лабораторная работа №3</p>
		<p class="main__subject">по дисциплине: «Теория автоматов и формальных языков»</p>
		<p class="main__topic">тема: «Регулярные языки и конечные распознаватели»</p>
	</div>
	<div class="footer">
		<div class="footer__student-info">
			<p class="footer__student-info__title">Выполнил студент группы ПВ-222</p>
			<p class="footer__student-info__item">Короткунов Александр Александрович</p>
		</div>
		<div class="footer__teachers-info">
			<p class="footer__teachers-info__title">Проверили</p>
			<p class="footer_teachers-info__item">Рязанов Юрий Дмитриевич</p>
		</div>
	</div>
	<div class="date">
		<p>Белгород 2025 г.</p>
	</div>
</div>

**Цель работы:** изучить основные способы задания регулярных языков, способы построения, алгоритмы преобразования, анализа и реализации конечных распознавателей.

<center>Вариант 8</center>

**Задание 1.** Язык $L_1$ в алфавите $\{0,1\}$, представляющий собой множество цепочек, в которых на предпоследнем месте стоит единица, задан грамматикой $G$. Построить детерминированный конечный распознаватель языка $L_1$.

Грамматика $G$:
1. S → A10
2. S → A11
3. A → 0A
4. A → 1A
5. A → ε

На основе данной грамматики можно построить следующее регулярное выражение $(0+1)^*(10+11)$

Так как по условию задачи, нам нужно, чтобы на предпоследнем месте стояла единичка, значит можно опустить все другие условия. Таким образом можно сформировать следующие состояния ДКР

$s_0$ - начальное состояние (пустая строка)
$s_1$ - последний символ - 0
$s_2$ - последний символ - 1
$s_3$ - последние два символа - 00
$s_4$ - последние два символа - 01
$s_5$ - последние два символа - 10
$s_6$ - последние два символа - 11

Во множество $F$ допускающих состояний войдёт лишь два состояния - $s_5$ и $s_6$

Сформируем таблицу переходов ДКР:

|     | $s_0$ | $s_1$ | $s_2$ | $s_3$ | $s_4$ | $s_5$ | $s_6$ |
| :-: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  0  | $s_1$ | $s_3$ | $s_5$ | $s_3$ | $s_5$ | $s_3$ | $s_5$ |
|  1  | $s_2$ | $s_4$ | $s_6$ | $s_4$ | $s_6$ | $s_4$ | $s_6$ |

Граф переходов:

![[dkr_1.svg]]

**Задание 2.** Язык $L_2$ в алфавите $\{0,1\}$, представляющий собой множество цепочек, в которых на последнем месте стоит единица, задан регулярным выражением: $(0+1)^*1$. Построить детерминированный конечный распознаватель языка $L_2$.

В отличие от первого задания, ДКР для данного регулярного выражения будет иметь всего 3 состояния, потому что нужно следить лишь за последним символом в цепочке.

$s_0$ - начальное состояние (пустая строка)
$s_1$ - последний символ - 0
$s_2$ - последний символ - 1

Во множество $F$ допускающих состояний войдёт лишь состояние - $s_2$

Сформируем таблицу переходов ДКР:

|     | $s_0$ | $s_1$ | $s_2$ |
| :-: | :---: | :---: | :---: |
|  0  | $s_1$ | $s_1$ | $s_1$ |
|  1  | $s_2$ | $s_2$ | $s_2$ |
Граф переходов:

![[dkr_2.svg]]

**Задание 3.** Построить минимальный детерминированный конечный распознаватель языка $L_3$ в алфавите $\{0,1\}$, представляющий собой множество цепочек, в которых хотя бы на одной из последних двух позиций стоит единица.

Данное задание подразумевает то, что цепочка может состоять из любого количество элементов алфавита, но при этом удовлетворительными цепочками будут те, которые заканчиваются на 01, 10 либо 11, но не 0. Такой распознаватель уже был реализован в первом задании, но нужно лишь дополнить множество допустимых состояний F несколькими состояниями. 

$s_0$ - начальное состояние (пустая строка)
$s_1$ - последний символ - 0
$s_2$ - последний символ - 1
$s_3$ - последние два символа - 00
$s_4$ - последние два символа - 01
$s_5$ - последние два символа - 10
$s_6$ - последние два символа - 11

Во множество $F$ допускающих состояний войдут следующие состояния - $s_2$, $s_4$, $s_5$ и $s_6$

Таблицу переходов ДКР:

|     | $s_0$ | $s_1$ | $s_2$ | $s_3$ | $s_4$ | $s_5$ | $s_6$ |
| :-: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|  0  | $s_1$ | $s_3$ | $s_5$ | $s_3$ | $s_5$ | $s_3$ | $s_5$ |
|  1  | $s_2$ | $s_4$ | $s_6$ | $s_4$ | $s_6$ | $s_4$ | $s_6$ |
Граф переходов аналогичный:

![[dkr_1.svg]]

Теперь по условию задания нужно привести ДКР к минимальному ДКР. Для этого нужно минимизировать уже существующий ДКР. 

**Шаг 1. Определить множество состояний, достижимых из начального**

Все состояния достижимы из начального, опираясь на граф

**Шаг 2. Найти эквивалентные состояния**

**Таблица переходов в классы 0-эквивалентных состояний:**

![[Pasted image 20250405165215 1.png]]

**Таблица переходов в классы 1-эквивалентных состояний:**

![[Pasted image 20250405165229.png]]

**Таблица переходов в классы 2-эквивалентных состояний:**

![[Pasted image 20250405165239.png]]

**Таблица переходов в классы 3-эквивалентных состояний:**

![[Pasted image 20250405165247.png]]

В итоге таблица свернулась к одному классу эквивалентности, делить таблицу стало невозможным, следовательно ДКР уже является минимальным. ДКР остаётся неизменным.

**Задание 4.** Написать программу компиляционного типа для реализации минимального детерминированного конечного распознавателя языка $L_3$.

```python
def is_valid():
    state = 0
    for x in input_str:
        if state == 0:
            if x == '0':
                state = 1
            elif x == '1':
                state = 2
        elif state == 1:
            if x == '0':
                state = 3
            elif x == '1':
                state = 4
        elif state == 3:
            if x == '0':
                state = 3
            elif x == '1':
                state = 4
        elif state == 4:
            if x == '0':
                state = 5
            elif x == '1':
                state = 6
        elif state == 5:
            if x == '0':
                state = 3
            elif x == '1':
                state = 4
        elif state == 6:
            if x == '0':
                state = 5
            elif x == '1':
                state = 6
    return state in (2, 4, 5, 6)
    
input_str = '00111'

print(is_valid())
```

**Задание 5.** Написать программу интерпретационного типа для реализации минимального детерминированного конечного распознавателя языка $L_3$.

```python
graph = {
    0: [1, 2],
    1: [3, 4],
    2: [5, 6],
    3: [3, 4],
    4: [5, 6],
    5: [3, 4],
    6: [5, 6]
}

def is_valid():
    state = 0
    for x in input_str:
        possible_states = graph[state]
        if x == '0':
            state = possible_states[0]
        elif x == '1':
            state = possible_states[1]
    return state in (2, 4, 5, 6)
    
input_str = '00111'

print(is_valid())
```

**Задание 6.** Подобрать наборы тестовых данных так, чтобы в процессе тестирования сработал каждый переход конечного распознавателя.

```python
test_cases = [
    '0',        
    '1',       
    '00',       
    '01',     
    '10',     
    '11',     
    '000',   
    '001',      
    '0110',   
    '0111',    
    '1000',    
    '1001',   
    '1100',   
    '1101'
]
```

**Задание 7.** Подобрать наборы тестовых данных так, чтобы в процессе тестирования распознаватель закончил обработку цепочек в каждом состоянии конечного распознавателя.

```python
test_cases = [
    '0',
    '1',
    '00',
    '01',
    '10',
    '11'
]
```

**Здаание 8.** Выполнить тестирование программ для реализации минимального детерминированного конечного распознавателя языка $L_3$.

Результат тестирования на основе тестов из задания 6

```
Test: 0
[0 -> 1]
Test: 1
[0 -> 2]
Test: 00
[0 -> 1 -> 3]
Test: 01
[0 -> 1 -> 4]
Test: 10
[0 -> 2 -> 5]
Test: 11
[0 -> 2 -> 6]
Test: 000
[0 -> 1 -> 3 -> 3]
Test: 001
[0 -> 1 -> 3 -> 4]
Test: 0110
[0 -> 1 -> 4 -> 6 -> 5]
Test: 0111
[0 -> 1 -> 4 -> 6 -> 6]
Test: 1000
[0 -> 2 -> 5 -> 3 -> 3]
Test: 1001
[0 -> 2 -> 5 -> 3 -> 4]
Test: 1100
[0 -> 2 -> 6 -> 5 -> 3]
Test: 1101
[0 -> 2 -> 6 -> 5 -> 4]


** Process exited - Return Code: 0 **
Press Enter to exit terminal
```

Результат тестирования на основе тестов задания 7

```
Test: 0
[0 -> 1]
Test: 1
[0 -> 2]
Test: 00
[0 -> 1 -> 3]
Test: 01
[0 -> 1 -> 4]
Test: 10
[0 -> 2 -> 5]
Test: 11
[0 -> 2 -> 6]


** Process exited - Return Code: 0 **
Press Enter to exit terminal
```

**Вывод:** изучили основные способы задания регулярных языков, способы построения, алгоритмы преобразования, анализа и реализации конечных распознавателей.